#pragma version =0.4.6;
#pragma allow-post-modification;
#pragma compute-asm-ltr;

;; mutating-methods_Tester.headers.fc
;;
;; Header files for Tester
;; NOTE: declarations are sorted for optimal order
;;

;; __tact_not_null
forall X -> X __tact_not_null(X x) impure inline;

;; $Tester$_store
builder $Tester$_store(builder build_0, (slice) v) inline;

;; $Tester$_load
(slice, ((slice))) $Tester$_load(slice sc_0) inline;

;; $Cell$_fun_asSlice
slice $Cell$_fun_asSlice(cell $self) impure inline;

;; $Tester$_contract_init
(slice) $Tester$_contract_init() impure inline;

;; $Tester$_contract_load
(slice) $Tester$_contract_load() impure inline_ref;

;; $Tester$_contract_store
() $Tester$_contract_store((slice) v) impure inline;

;; $MyStruct$_constructor_age
((int)) $MyStruct$_constructor_age(int $age) inline;

;; $Int$_fun_multiply
(int, int) $Int$_fun_multiply(int $self, int $x) impure inline_ref;

;; $Int$_fun_multiply$not_mut
int $Int$_fun_multiply$not_mut(int $self, int $x) impure inline_ref;

;; $Int$_fun_multiplyExtends
int $Int$_fun_multiplyExtends(int $self, int $x) impure inline_ref;

;; $Builder$_fun_asSlice
slice $Builder$_fun_asSlice(builder $self) impure inline;

;; $Slice$_fun_loadRef$not_mut
cell $Slice$_fun_loadRef$not_mut(slice $self) impure inline_ref;

;; load_int$not_mut
int load_int$not_mut(slice $self, int $l) impure inline_ref;

;; load_uint$not_mut
int load_uint$not_mut(slice $self, int $l) impure inline_ref;

;; $MyStruct$_fun_setAge
((int), int) $MyStruct$_fun_setAge((int) $self, int $age) impure inline_ref;

;; $MyStruct$_fun_setAge$not_mut
int $MyStruct$_fun_setAge$not_mut((int) $self, int $age) impure inline_ref;

;; $Tester$_fun_test1
((slice), int) $Tester$_fun_test1((slice) $self) impure inline_ref;

;; $Tester$_fun_test2
((slice), int) $Tester$_fun_test2((slice) $self) impure inline_ref;

;; $Tester$_fun_test3
((slice), int) $Tester$_fun_test3((slice) $self) impure inline_ref;

;; $Tester$_fun_test4
((slice), int) $Tester$_fun_test4((slice) $self) impure inline_ref;

;; $Tester$_fun_test5
((slice), int) $Tester$_fun_test5((slice) $self) impure inline_ref;

;; $Tester$_fun_test6
((slice), ()) $Tester$_fun_test6((slice) $self) impure inline_ref;

;; $Tester$_fun_test7
((slice), int) $Tester$_fun_test7((slice) $self) impure inline_ref;

;; $Foo$_constructor_s
((slice)) $Foo$_constructor_s(slice $s) inline;

;; $Tester$_fun_test8
((slice), int) $Tester$_fun_test8((slice) $self) impure inline_ref;

;; $Tester$_fun_test9
((slice), int) $Tester$_fun_test9((slice) $self) impure inline_ref;

;; $Tester$_fun_test10
((slice), cell) $Tester$_fun_test10((slice) $self, cell $dict) impure inline_ref;

;; $Tester$_fun_test11
((slice), int) $Tester$_fun_test11((slice) $self, int $x) impure inline_ref;

;; $Tester$_fun_test12
((slice), int) $Tester$_fun_test12((slice) $self) impure inline_ref;


;; mutating-methods_Tester.stdlib.fc
global (int, slice, int, slice) __tact_context;
global slice __tact_context_sender;
global cell __tact_child_contract_codes;
global int __tact_randomized;

forall X -> X __tact_not_null(X x) impure inline {
    throw_if(128, null?(x)); return x;
}

slice $Cell$_fun_beginParse(cell $self) impure asm """
    CTOS
""";

slice $Cell$_fun_asSlice(cell $self) impure inline {
    var ($self) = $self;
    return $Cell$_fun_beginParse($self);
}

cell $Builder$_fun_endCell(builder $self) impure asm """
    ENDC
""";

builder $global_beginCell() impure asm """
    NEWC
""";

slice $global_emptySlice() impure asm """
    b{} PUSHSLICE
""";

slice $Builder$_fun_asSlice(builder $self) impure inline {
    var ($self) = $self;
    return $Cell$_fun_beginParse($Builder$_fun_endCell($self));
}

(slice, cell) $Slice$_fun_loadRef(slice $self) impure asm( -> 1 0) """
    LDREF
""";

cell $Slice$_fun_loadRef$not_mut(slice $self) impure inline_ref {
    return $self~$Slice$_fun_loadRef();
}

int load_int$not_mut(slice $self, int $l) impure inline_ref {
    return $self~load_int($l);
}

int load_uint$not_mut(slice $self, int $l) impure inline_ref {
    return $self~load_uint($l);
}

;; mutating-methods_Tester.constants.fc
;; String "abc"
slice __gen_slice_string_55e960f1409af0d7670e382c61276a559fa9330185984d91faffebf32d5fa383() asm """
    B{b5ee9c724101010100050000066162631d957013} B>boc <s PUSHSLICE
""";

;; Slice tOA/OTd/5/7Tjcbq4t6mwpR/RfszIdHmKf9hMBqeAG4=
slice __gen_slice_slice_b4e03f39377fe7fed38dc6eae2dea6c2947f45fb3321d1e629ff61301a9e006e() asm """
    B{b5ee9c724101010100040000034568b80797f8} B>boc <s PUSHSLICE
""";

;; mutating-methods_Tester.storage.fc
;;
;; Type: Foo
;; TLB: _ s:^slice = Foo
;;

((slice)) $Foo$_constructor_s(slice $s) inline {
    return ($s);
}

;;
;; Type: MyStruct
;; TLB: _ age:int257 = MyStruct
;;

((int)) $MyStruct$_constructor_age(int $age) inline {
    return ($age);
}

;;
;; Type: Tester
;;

builder $Tester$_store(builder build_0, (slice) v) inline {
    var (v's) = v;
    build_0 = build_0.store_ref(begin_cell().store_slice(v's).end_cell());
    return build_0;
}

(slice, ((slice))) $Tester$_load(slice sc_0) inline {
    var v's = sc_0~load_ref().begin_parse();
    return (sc_0, (v's));
}

(slice) $Tester$_contract_load() impure inline_ref {
    slice $sc = get_data().begin_parse();
    int $loaded = $sc~load_int(1);
    if ($loaded) {
        return $sc~$Tester$_load();
    } else {
        return $Tester$_contract_init();
    }
}

() $Tester$_contract_store((slice) v) impure inline {
    builder b = begin_cell();
    b = b.store_int(true, 1);
    b = $Tester$_store(b, v);
    set_data(b.end_cell());
}

;;
;; Contract Tester functions
;;

(slice) $Tester$_contract_init() impure inline {
    var (($self's)) = (null());
    $self's = $Cell$_fun_asSlice($Builder$_fun_endCell(store_uint(store_uint($global_beginCell(), 3, 2), 1, 2)));
    return ($self's);
}

(int, int) $Int$_fun_multiply(int $self, int $x) impure inline_ref {
    var ($self) = $self;
    $self = $self * $x;
    var $fresh$ret_572 = $self;
    return ($self, $fresh$ret_572);
}

int $Int$_fun_multiply$not_mut(int $self, int $x) impure inline_ref {
    return $self~$Int$_fun_multiply($x);
}

int $Int$_fun_multiplyExtends(int $self, int $x) impure inline_ref {
    if (null?($self)) {
        return null();
    }
    return (__tact_not_null($self) * $x);
}

(cell, ()) $Cell$_fun_nativeUdictStoreUint(cell $self, int $keySize, int $key, slice $value) impure asm($value $key $self $keySize) """
    DICTUSET
""";

((int), int) $MyStruct$_fun_setAge((int) $self, int $age) impure inline_ref {
    var (($self'age)) = $self;
    var (($self'age)) = $self;
    int $old = $self'age;
    $self'age = $age;
    var $fresh$ret_573 = ($old + $self'age);
    return (($self'age), $fresh$ret_573);
}

int $MyStruct$_fun_setAge$not_mut((int) $self, int $age) impure inline_ref {
    return $self~$MyStruct$_fun_setAge($age);
}

((slice), int) $Tester$_fun_test1((slice) $self) impure inline_ref {
    var (($self's)) = $self;
    int $x = load_uint$not_mut($Cell$_fun_beginParse($Builder$_fun_endCell(store_uint($global_beginCell(), 0, 1))), 1);
    var $fresh$ret_574 = $x;
    return (($self's), $fresh$ret_574);
}

((slice), int) $Tester$_fun_test2((slice) $self) impure inline_ref {
    var (($self's)) = $self;
    cell $y = $Builder$_fun_endCell(store_uint($global_beginCell(), 0, 1));
    slice $x = $Cell$_fun_beginParse($Builder$_fun_endCell(store_uint($global_beginCell(), load_uint$not_mut($Cell$_fun_beginParse($y), 1), 1)));
    var $fresh$ret_575 = $x~load_uint(1);
    return (($self's), $fresh$ret_575);
}

((slice), int) $Tester$_fun_test3((slice) $self) impure inline_ref {
    var (($self's)) = $self;
    int $x = 3;
    $x~$Int$_fun_multiply(2);
    var $fresh$ret_576 = $x;
    return (($self's), $fresh$ret_576);
}

((slice), int) $Tester$_fun_test4((slice) $self) impure inline_ref {
    var (($self's)) = $self;
    int $x = 3;
    var $fresh$ret_577 = $Int$_fun_multiply$not_mut($x~$Int$_fun_multiply(2), 4);
    return (($self's), $fresh$ret_577);
}

((slice), int) $Tester$_fun_test5((slice) $self) impure inline_ref {
    var (($self's)) = $self;
    var $fresh$ret_578 = load_uint$not_mut(__tact_str_to_slice(__gen_slice_string_55e960f1409af0d7670e382c61276a559fa9330185984d91faffebf32d5fa383()), 8);
    return (($self's), $fresh$ret_578);
}

((slice), ()) $Tester$_fun_test6((slice) $self) impure inline_ref {
    var (($self's)) = $self;
    $Slice$_fun_loadRef$not_mut($global_emptySlice());
    return (($self's), ());
}

((slice), int) $Tester$_fun_test7((slice) $self) impure inline_ref {
    var (($self's)) = $self;
    var $fresh$ret_579 = load_int$not_mut($Builder$_fun_asSlice(store_int($global_beginCell(), 42, 7)), 7);
    return (($self's), $fresh$ret_579);
}

((slice), int) $Tester$_fun_test8((slice) $self) impure inline_ref {
    var (($self's)) = $self;
    var ($foo's) = $Foo$_constructor_s($Cell$_fun_asSlice($Builder$_fun_endCell(store_uint(store_uint($global_beginCell(), 3, 2), 1, 2))));
    $foo's~load_bits(1);
    var $fresh$ret_580 = $foo's~load_uint(3);
    return (($self's), $fresh$ret_580);
}

((slice), int) $Tester$_fun_test9((slice) $self) impure inline_ref {
    var (($self's)) = $self;
    $self's~load_uint(1);
    var $fresh$ret_581 = $self's~load_uint(3);
    return (($self's), $fresh$ret_581);
}

((slice), cell) $Tester$_fun_test10((slice) $self, cell $dict) impure inline_ref {
    var (($self's)) = $self;
    $dict~$Cell$_fun_nativeUdictStoreUint(8, 123, __gen_slice_slice_b4e03f39377fe7fed38dc6eae2dea6c2947f45fb3321d1e629ff61301a9e006e());
    var $fresh$ret_582 = $dict;
    return (($self's), $fresh$ret_582);
}

((slice), int) $Tester$_fun_test11((slice) $self, int $x) impure inline_ref {
    var (($self's)) = $self;
    $Int$_fun_multiplyExtends($x, 2);
    $Int$_fun_multiplyExtends($Int$_fun_multiplyExtends($x, 2), 3);
    var $fresh$ret_583 = $Int$_fun_multiplyExtends($Int$_fun_multiplyExtends($x, 2), 3);
    return (($self's), $fresh$ret_583);
}

((slice), int) $Tester$_fun_test12((slice) $self) impure inline_ref {
    var (($self's)) = $self;
    var $fresh$ret_584 = $MyStruct$_fun_setAge$not_mut($MyStruct$_constructor_age(10), 20);
    return (($self's), $fresh$ret_584);
}

;;
;; Get methods of a Contract Tester
;;

_ %test1() method_id(70304) {
    var self = $Tester$_contract_load();
    var res = self~$Tester$_fun_test1();
    return res;
}

_ %test2() method_id(74435) {
    var self = $Tester$_contract_load();
    var res = self~$Tester$_fun_test2();
    return res;
}

_ %test3() method_id(78562) {
    var self = $Tester$_contract_load();
    var res = self~$Tester$_fun_test3();
    return res;
}

_ %test4() method_id(82437) {
    var self = $Tester$_contract_load();
    var res = self~$Tester$_fun_test4();
    return res;
}

_ %test5() method_id(86564) {
    var self = $Tester$_contract_load();
    var res = self~$Tester$_fun_test5();
    return res;
}

_ %test6() method_id(90695) {
    var self = $Tester$_contract_load();
    var res = self~$Tester$_fun_test6();
    return res;
}

_ %test7() method_id(94822) {
    var self = $Tester$_contract_load();
    var res = self~$Tester$_fun_test7();
    return res;
}

_ %test8() method_id(99209) {
    var self = $Tester$_contract_load();
    var res = self~$Tester$_fun_test8();
    return res;
}

_ %test9() method_id(103336) {
    var self = $Tester$_contract_load();
    var res = self~$Tester$_fun_test9();
    return res;
}

_ %test10(cell $dict) method_id(107552) {
    cell $dict = $dict;
    var self = $Tester$_contract_load();
    var res = self~$Tester$_fun_test10($dict);
    return res;
}

_ %test11(int $x) method_id(111617) {
    int $x = $x;
    var self = $Tester$_contract_load();
    var res = self~$Tester$_fun_test11($x);
    return res;
}

_ %test12() method_id(99426) {
    var self = $Tester$_contract_load();
    var res = self~$Tester$_fun_test12();
    return res;
}

;;
;; Routing of a Contract Tester
;;

() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
    
    ;; Context
    var cs = in_msg_cell.begin_parse();
    cs~skip_bits(2);
    var msg_bounceable = cs~load_int(1);
    var msg_bounced = cs~load_int(1);
    slice msg_sender_addr = cs~load_msg_addr();
    __tact_context = (msg_bounceable, msg_sender_addr, msg_value, cs);
    __tact_context_sender = msg_sender_addr;
    
    ;; Load contract data
    var ($self's) = $Tester$_contract_load();
    
    ;; Handle bounced messages
    if (msg_bounced) { return (); }
    int op = 0;
    int in_msg_length = slice_bits(in_msg);
    if (in_msg_length >= 32) {
        op = in_msg~load_uint(32);
    }
    ;; Receive empty message
    if ((op == 0) & (in_msg_length <= 32)) {
        ;; Persist state
        $Tester$_contract_store(($self's));
        return ();
    }
    ;; Throw if not handled
    throw(130);
}
